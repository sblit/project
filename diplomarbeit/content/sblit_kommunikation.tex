Um zu verhindern, dass Daten mitgelesen werden, verwendet \sblit den sicheren \nameref{Applicationchannel} (siehe Seite \pageref{Applicationchannel}) der Kommunikationsschicht.\\
\sblitg verwendet zur Kommunikation fünf verschiedene Nachrichten:
\begin{itemize}
	\item Authentifizierungsanfragen
	\item Antworten auf Authentifizierungsanfragen
	\item Dateianfragen
	\item Antworten auf Dateianfragen
	\item Die eigentliche Übertragung der Datei
	\item Löschanfragen
\end{itemize}
\subsection{\gls{authreq}}
Angenommen zwei Geräte eines Besitzers wollen Daten austauschen. Wie können sich diese sicher sein, dass es sich auch um das richtige Gerät handelt? Hier kommt die Authentifizierung ins Spiel. \gls{authreq}s dienen zur Sicherstellung der Authentizität des Gerätes (im Folgenden Gerät A), mit dem ein anderes Gerät (im Folgenden Gerät B) eine Verbindung aufbaut. Dazu schickt das Gerät B zufällige Daten an Gerät A mit der Aufforderung, diese zu verschlüsseln. Die Nachricht ist dabei folgendermaßen aufgebaut:
\begin{figure}[H]
\begin{centering}

\begin{bytefield}[bitwidth=3em]{8}
	\\
	\bitheader{0-7} \\
	
	\begin{rightwordgroup}{\isprotomsgtype}
		\wordbox[tlr]{1}{0}
	\end{rightwordgroup} \\
	
	\begin{rightwordgroup}{\isprotomsgdata}
		\wordbox[tblr]{4}{Zufallsdaten, 64 Bytes} 
	\end{rightwordgroup}
	
\end{bytefield}

\par\end{centering}
\protect\caption{\gls{authreq}}
\end{figure}
%TODO Umformulieren
Die Gesamtlänge der Daten, die mit RSA-2048 verschlüsselt werden, darf maximal 128 Byte lang sein. Um Gerät A 64 Byte zur Verfügung zu stellen, beträgt die Länge der von Gerät B gesendeten Daten 64 Byte. Diese 64 Byte werden von Gerät A benötigt, um zu verhindern, dass Gerät B sich gewünschte Werte von Gerät A verschlüsseln lässt.

\subsection{\gls{authres}}
Bevor die Daten wieder zurückgeschickt werden, müssen diese von Gerät B verschlüsselt werden. Dies geschieht mit dem Private-Key des Gerätes B. Dabei wird vorher noch ein zufälliger Wert an die empfangenen Daten angefügt, um das unter Authentifizierungsanfragen beschriebene Problem zu lösen.\\
Der Aufbau der Nachricht lautet wie folgt:
\begin{figure}[H]
\begin{centering}

\begin{bytefield}[bitwidth=3em]{8}
	\\
	\bitheader{0-7} \\
	
	\begin{rightwordgroup}{\isprotomsgtype}
		\wordbox[tlr]{1}{1}
	\end{rightwordgroup} \\
	
	\begin{rightwordgroup}{\isprotomsgdata}
		\wordbox[tblr]{4}{Verschlüsselte Daten, 128 Bytes} 
	\end{rightwordgroup}
	
\end{bytefield}

\par\end{centering}
\protect\caption{\gls{authres}}
\end{figure}
Wird dieses Paket nun von Gerät B empfangen, kann der Inhalt mit dem Public-Key des Gerätes A, also dessen Adresse, entschlüsselt werden. Von den erhaltenen Daten werden die ersten 64 Byte mit den ursprünglich gesendeten 64 Byte verglichen. Stimmen die beiden Werte überein, kann das Gerät seine Authentizität beweisen. Stimmen diese jedoch nicht überein, handelt es sich um einen Betrüger, der offensichtlich den richtigen Private-Key zur von ihm angegebenen Adresse nicht kennt.
		
\subsection{\gls{filereq}} \label{Dateianfrage}
Bevor eine Datei an ein anderes Gerät (im Folgenden Gerät B) verschickt wird, schickt das Gerät, das die Datei besitzt (im Folgenden Gerät A), eine Dateianfrage an das Gerät B. Dies hat 2 Gründe: Erstens muss eruiert werden, ob die Datei überhaupt von Gerät B benötigt wird, oder ob besagtes Gerät schon diese Datei besitzt. Zweitens besteht die Möglichkeit eines Konfliktes \referenz{Konflikt}. Daher ist die Dateianfrage folgendermaßen aufgebaut:
\begin{figure}[H]
\begin{centering}

\begin{bytefield}[bitwidth=3em]{8}
	\\
	\bitheader{0-7} \\
	
	\begin{rightwordgroup}{\isprotomsgtype}
		\wordbox[tlr]{1}{2}
	\end{rightwordgroup} \\
	
	\begin{rightwordgroup}{\isprotomsgdata}
		\wordbox[tlr]{2}{Dateipfad, variable Länge} \\
		\skippedwords \\
		\wordbox[lr]{1}{} \\
		\wordbox[tlr]{2}{Versionsverlauf, variable Länge} \\
		\skippedwords \\
		\wordbox[blr]{1}{}
	\end{rightwordgroup}
	
\end{bytefield}
\par\end{centering}
\protect\caption{\gls{filereq}}
\end{figure}
\begin{description} 
	\item[{Dateipfad}] \hfill \\
		Hierbei wird der zu \sblit's Hauptordner relative Dateipfad mitgeschickt. Der absolute Dateipfad wird aus dem Grund nicht mitgeschickt, da der Ort des \sblit-Ordners nicht auf allen Geräten gleich sein muss. Befindet sich der Ordner auf Gerät A beispielsweise unter C:/Users/Susanne/ kann sich der Ordner auf Gerät B auch unter /home/susanne/dateien/ befinden.
	\item[{Versionsverlauf}] \hfill \\
		Der Versionsverlauf beinhaltet alle Hashes einer Datei seit der letzten komplett synchronisierten Version. Das heißt, dass auf jedem Gerät aktuell entweder diese oder eine neuere Version gespeichert ist.
\end{description}

		
\subsection{\gls{fileres}}
Die Antwort auf eine Dateianfrage beinhaltet folgende Parameter: 

\begin{figure}[H]
\begin{centering}

\begin{bytefield}[bitwidth=3em]{8}
	\\
	\bitheader{0-7} \\
	
	\begin{rightwordgroup}{\isprotomsgtype}
		\wordbox[tlr]{1}{3}
	\end{rightwordgroup} \\
	
	\begin{rightwordgroup}{\isprotomsgdata}
		\wordbox[tlr]{1}{Need-Flag, 1 Byte} \\
		\wordbox[tlr]{2}{Dateipfad, variable Länge} \\
		\skippedwords \\
		\wordbox[lr]{1}{} \\
		\wordbox[tlr]{2}{Hash, variable Länge} \\
		\skippedwords \\
		\wordbox[blr]{1}{}
	\end{rightwordgroup}
	
\end{bytefield}
\par\end{centering}
\protect\caption{\gls{fileres}}
\end{figure}

\begin{description}
	\item[{Need-Flag}] \hfill \\
		Dieses Feld enthält einen Hexadezimalwert, der darüber Auskunft gibt, ob die Datei benötigt wird oder nicht. Steht in diesem Feld der Hexadezimalwert 0x00, wird die Datei nicht benötigt. Steht hier hingegen der Hexadezimalwert 0x01, wird die Datei benötigt. Dieses Byte hilft den Datenverkehr zu reduzieren. So muss nicht eine ganze Datei verschickt werden muss, obwohl diese gar nicht gebraucht wird.
	\item[{Dateipfad}] \hfill \\
		Wie auch bei der Dateianfrage wird in der Antwort auf die Dateianfrage der zu \sblit's Hauptordner relative Pfad mitgeschickt.
	\item[{Hash}] \hfill \\
		Hier wird noch einmal der letzte Hash des Versionsverlaufs der Dateianfrage verschickt, um sicherzustellen, dass die Datei in der Zwischenzeit nicht geändert wurde. 
\end{description}
Nach Empfang der Dateianfrage wird zunächst geprüft, ob die Datei vorhanden und in der aktuellst ist.  Ist die lokale Datei nicht aktuell, wird das Need-Flag, auf den Hexadezimalwert 0x01 gesetzt. Ist die Datei auf dem aktuellsten Stand, wird besagtes Flag auf den Hexadezimalwert 0x00 gesetzt. Außerdem wird überprüft, ob ein Konflikt aufgetreten ist \referenz{Konflikterkennung}.\\
Nach Empfang der Antwort wird zunächst überprüft, ob der Hashwert der Datei mit dem erhaltenen Pfad übereinstimmt. Stimmt der Hashwert in der Anfrage nicht mit dem aktuellen Hashwert überein, wird die Antwort verworfen. Dies kann beispielsweise passieren, wenn in der Zwischenzeit eine neuere Version der Datei erzeugt wurde. Stimmt dieser jedoch überein, kann die Datei nun im nächsten Schritt verschickt werden.
		
\subsection{Die eigentliche Übertragung der Datei}
Bei der eigentlichen Übertragung der Datei werden folgenden Daten mit der Datei mitgesendet: 
\begin{figure}[H]
\begin{centering}

\begin{bytefield}[bitwidth=3em]{8}
	\\
	\bitheader{0-7} \\
	
	\begin{rightwordgroup}{\isprotomsgtype}
		\wordbox[tlr]{1}{5}
	\end{rightwordgroup} \\
	
	\begin{rightwordgroup}{\isprotomsgdata}
		\wordbox[tlr]{2}{Dateiinhalt, variable Länge} \\
		\skippedwords \\
		\wordbox[lr]{1}{} \\
		\wordbox[tlr]{2}{Dateipfad, variable Länge} \\
		\skippedwords \\
		\wordbox[lr]{1}{} \\
		\wordbox[tlr]{2}{Hashes, variable Länge} \\
		\skippedwords \\
		\wordbox[lr]{1}{} \\
		\wordbox[tlr]{2}{Geräte mit der aktuellen Verision, variable Länge} \\
		\skippedwords \\
		\wordbox[blr]{1}{}
	\end{rightwordgroup}
	
\end{bytefield}
\par\end{centering}
\protect\caption{\gls{filemsg}}
\end{figure}

\begin{description}
	\item[{Dateiinhalt}] \hfill \\
		Der Dateiinhalt wird als binäres \code{Data}-Objekt verschickt.
	\item[{Geräte mit der aktuellen Version}] \hfill \\
		Hier stehen die Adressen aller Geräte, die die neuste Version schon haben. Ist die Version auf allen Geräten aktuell, kann diese von den Partnergeräten gelöscht werden. Daher wird diese Liste an Geräten immer mit der Datei mitgeschickt. Außerdem können somit unnötige Anfragen an Geräte, die die Datei schon besitzen verhindert werden.
	\item[{Dateipfad}] \hfill \\
		Der Dateipfad wird benötigt, damit die Datei auf dem zu synchronisierenden Gerät weiß, an welchen Ort die Datei gespeichert werden soll. Dies ist der gleiche relative Ort, wie auf dem Gerät, das die Anfrage geschickt hat.
	\item[{Hashes}] \hfill \\
		Die Hashes werden mitgeschickt, um einen einheitlichen Versionsverlauf sicherzustellen. Das verhindert das auftreten von Konflikten, welche gar keine sind. Weiters dient der aktuellste Hash dazu,  sicherzustellen, dass die Datei, die versendet wurde, auch so ankommt, wie sie versendet wurde. Verhasht man die neue Datei, muss das Ergebnis mit dem aktuellsten mitgeschickten Hash übereinstimmen. Andernfalls muss die Datei neu gesendet werden.
\end{description}
		
\subsection{Löschanfrage}
\begin{figure}[H]
\begin{centering}

\begin{bytefield}[bitwidth=3em]{8}
	\\
	\bitheader{0-7} \\
	
	\begin{rightwordgroup}{\isprotomsgtype}
		\wordbox[tlr]{1}{5}
	\end{rightwordgroup} \\
	
	\begin{rightwordgroup}{\isprotomsgdata}
		\wordbox[tlr]{2}{Dateipfad, variable Länge} \\
		\skippedwords \\
		\wordbox[blr]{1}{} \\
	\end{rightwordgroup}
	
\end{bytefield}
\par\end{centering}
\protect\caption{\gls{filemsg}}
\end{figure}		
Eine Löschanfrage beinhaltet den Pfad der zu löschenden Datei. Nach Empfang der Löschanfrage wird die Datei gelöscht.

